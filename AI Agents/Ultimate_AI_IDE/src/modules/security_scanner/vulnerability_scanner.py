"""
Vulnerability Scanner

Scans for known CVEs and security vulnerabilities in dependencies.
"""

import logging
import json
import subprocess
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from .scanner import SecurityIssue

logger = logging.getLogger(__name__)


@dataclass
class CVEInfo:
    """CVE (Common Vulnerabilities and Exposures) information"""
    cve_id: str
    description: str
    cvss_score: float
    severity: str
    affected_versions: List[str]
    fixed_versions: List[str]
    references: List[str]
    published_date: Optional[str] = None


class VulnerabilityScanner:
    """
    Scans for known vulnerabilities (CVEs) in project dependencies.
    
    Supports multiple languages and package managers:
    - Python: pip, safety, pip-audit
    - JavaScript/Node: npm audit, yarn audit
    - C#: dotnet list package --vulnerable
    - Java: OWASP Dependency-Check
    """
    
    def __init__(self):
        """Initialize vulnerability scanner"""
        self.known_cves: Dict[str, CVEInfo] = {}
    
    def scan(self, project_path: Path) -> List[SecurityIssue]:
        """
        Scan project for vulnerabilities.
        
        Args:
            project_path: Path to project root
            
        Returns:
            List of security issues found
        """
        issues = []
        
        try:
            # Detect project type and scan accordingly
            if (project_path / "requirements.txt").exists() or (project_path / "setup.py").exists():
                issues.extend(self._scan_python(project_path))
            
            if (project_path / "package.json").exists():
                issues.extend(self._scan_nodejs(project_path))
            
            if (project_path / "*.csproj").exists():
                issues.extend(self._scan_dotnet(project_path))
            
            logger.info(f"Vulnerability scan found {len(issues)} issues")
            return issues
            
        except Exception as e:
            logger.error(f"Error during vulnerability scan: {e}")
            return issues
    
    def _scan_python(self, project_path: Path) -> List[SecurityIssue]:
        """Scan Python project for vulnerabilities"""
        issues = []
        
        try:
            # Try using safety first
            result = self._run_safety(project_path)
            if result:
                issues.extend(result)
            else:
                # Fallback to pip-audit
                result = self._run_pip_audit(project_path)
                if result:
                    issues.extend(result)
        except Exception as e:
            logger.warning(f"Python vulnerability scan failed: {e}")
        
        return issues
    
    def _run_safety(self, project_path: Path) -> List[SecurityIssue]:
        """Run safety check on Python dependencies"""
        issues = []
        
        try:
            # Check if safety is installed
            result = subprocess.run(
                ['safety', 'check', '--json'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 or result.stdout:
                data = json.loads(result.stdout) if result.stdout else []
                
                for vuln in data:
                    issue = SecurityIssue(
                        severity=self._map_severity(vuln.get('severity', 'medium')),
                        category='vulnerability',
                        title=f"Vulnerability in {vuln.get('package', 'unknown')}",
                        description=vuln.get('advisory', 'No description'),
                        cve_id=vuln.get('cve'),
                        cvss_score=vuln.get('cvss_score'),
                        fix_available=bool(vuln.get('fixed_in')),
                        fix_description=f"Update to version {vuln.get('fixed_in', 'latest')}" if vuln.get('fixed_in') else None,
                        references=[vuln.get('more_info_url')] if vuln.get('more_info_url') else []
                    )
                    issues.append(issue)
        
        except FileNotFoundError:
            logger.debug("safety not installed, skipping")
        except Exception as e:
            logger.warning(f"safety check failed: {e}")
        
        return issues
    
    def _run_pip_audit(self, project_path: Path) -> List[SecurityIssue]:
        """Run pip-audit on Python dependencies"""
        issues = []
        
        try:
            result = subprocess.run(
                ['pip-audit', '--format', 'json'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout:
                data = json.loads(result.stdout)
                
                for vuln in data.get('vulnerabilities', []):
                    issue = SecurityIssue(
                        severity='high',
                        category='vulnerability',
                        title=f"Vulnerability in {vuln.get('name', 'unknown')}",
                        description=vuln.get('description', 'No description'),
                        cve_id=vuln.get('id'),
                        fix_available=bool(vuln.get('fix_versions')),
                        fix_description=f"Update to version {', '.join(vuln.get('fix_versions', []))}" if vuln.get('fix_versions') else None
                    )
                    issues.append(issue)
        
        except FileNotFoundError:
            logger.debug("pip-audit not installed, skipping")
        except Exception as e:
            logger.warning(f"pip-audit failed: {e}")
        
        return issues
    
    def _scan_nodejs(self, project_path: Path) -> List[SecurityIssue]:
        """Scan Node.js project for vulnerabilities"""
        issues = []
        
        try:
            # Try npm audit
            result = subprocess.run(
                ['npm', 'audit', '--json'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout:
                data = json.loads(result.stdout)
                
                for vuln_id, vuln in data.get('vulnerabilities', {}).items():
                    issue = SecurityIssue(
                        severity=vuln.get('severity', 'medium'),
                        category='vulnerability',
                        title=f"Vulnerability in {vuln.get('name', 'unknown')}",
                        description=vuln.get('title', 'No description'),
                        cve_id=vuln.get('cve', [None])[0] if vuln.get('cve') else None,
                        cvss_score=vuln.get('cvss', {}).get('score'),
                        fix_available=bool(vuln.get('fixAvailable')),
                        fix_description="Run 'npm audit fix' to fix" if vuln.get('fixAvailable') else None,
                        references=vuln.get('references', [])
                    )
                    issues.append(issue)
        
        except FileNotFoundError:
            logger.debug("npm not found, skipping Node.js scan")
        except Exception as e:
            logger.warning(f"npm audit failed: {e}")
        
        return issues
    
    def _scan_dotnet(self, project_path: Path) -> List[SecurityIssue]:
        """Scan .NET project for vulnerabilities"""
        issues = []
        
        try:
            result = subprocess.run(
                ['dotnet', 'list', 'package', '--vulnerable', '--include-transitive'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout and 'vulnerable' in result.stdout.lower():
                # Parse output (simplified - real implementation would be more robust)
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'vulnerable' in line.lower():
                        issue = SecurityIssue(
                            severity='high',
                            category='vulnerability',
                            title="Vulnerable .NET package detected",
                            description=line.strip(),
                            fix_available=True,
                            fix_description="Update the affected package"
                        )
                        issues.append(issue)
        
        except FileNotFoundError:
            logger.debug("dotnet not found, skipping .NET scan")
        except Exception as e:
            logger.warning(f"dotnet vulnerability scan failed: {e}")
        
        return issues
    
    def _map_severity(self, severity: str) -> str:
        """Map various severity formats to standard levels"""
        severity = severity.lower()
        
        if severity in ['critical', 'high']:
            return 'critical' if severity == 'critical' else 'high'
        elif severity in ['medium', 'moderate']:
            return 'medium'
        else:
            return 'low'
    
    def check_cve(self, cve_id: str) -> Optional[CVEInfo]:
        """
        Look up specific CVE information.
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)
            
        Returns:
            CVE information if found
        """
        # This would integrate with NIST NVD API in production
        # For now, return cached info if available
        return self.known_cves.get(cve_id)
