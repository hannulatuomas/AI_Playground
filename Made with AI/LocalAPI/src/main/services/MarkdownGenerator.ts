// Markdown Documentation Generator Service
// Generates comprehensive API documentation from collections in Markdown format

import type { Collection, Request, Header, QueryParam } from '../../types/models';
import * as fs from 'fs';
import * as path from 'path';

interface GeneratorOptions {
  includeTableOfContents?: boolean;
  includeExamples?: boolean;
  includeHeaders?: boolean;
  includeQueryParams?: boolean;
  includeBody?: boolean;
  includeAuth?: boolean;
  groupByFolder?: boolean;
  format?: 'github' | 'gitlab' | 'standard';
}

export class MarkdownGenerator {
  /**
   * Generate Markdown documentation from a collection
   */
  generateFromCollection(
    collection: Collection,
    options: GeneratorOptions = {}
  ): string {
    const opts = {
      includeTableOfContents: true,
      includeExamples: true,
      includeHeaders: true,
      includeQueryParams: true,
      includeBody: true,
      includeAuth: true,
      groupByFolder: false,
      format: 'github' as const,
      ...options,
    };

    let markdown = '';

    // Title and description
    markdown += `# ${collection.name}\n\n`;
    if (collection.description) {
      markdown += `${collection.description}\n\n`;
    }

    // Metadata
    markdown += `---\n\n`;
    markdown += `**Generated:** ${new Date().toISOString()}\n\n`;
    markdown += `**Total Endpoints:** ${collection.requests?.length || 0}\n\n`;

    // Table of Contents
    if (opts.includeTableOfContents && collection.requests?.length > 0) {
      markdown += this.generateTableOfContents(collection, opts);
    }

    // Requests
    if (collection.requests?.length > 0) {
      markdown += `## Endpoints\n\n`;
      
      for (const request of collection.requests) {
        markdown += this.generateRequestDocumentation(request, opts);
      }
    }

    // Footer
    markdown += `---\n\n`;
    markdown += `*Documentation generated by LocalAPI*\n`;

    return markdown;
  }

  /**
   * Generate table of contents
   */
  private generateTableOfContents(
    collection: Collection,
    options: GeneratorOptions
  ): string {
    let toc = `## Table of Contents\n\n`;

    if (collection.requests) {
      for (const request of collection.requests) {
        const anchor = this.createAnchor(request.name);
        const method = request.method.toUpperCase();
        const badge = this.getMethodBadge(method, options.format!);
        toc += `- ${badge} [${request.name}](#${anchor})\n`;
      }
    }

    toc += `\n`;
    return toc;
  }

  /**
   * Generate documentation for a single request
   */
  private generateRequestDocumentation(
    request: Request,
    options: GeneratorOptions
  ): string {
    let doc = '';

    // Request header
    const method = request.method.toUpperCase();
    const badge = this.getMethodBadge(method, options.format!);
    doc += `### ${badge} ${request.name}\n\n`;

    if (request.description) {
      doc += `${request.description}\n\n`;
    }

    // Endpoint
    doc += `**Endpoint:** \`${method} ${request.url}\`\n\n`;

    // Authentication
    if (options.includeAuth && request.auth && request.auth.type !== 'none') {
      doc += this.generateAuthDocumentation(request);
    }

    // Headers
    if (options.includeHeaders && request.headers?.length > 0) {
      doc += this.generateHeadersDocumentation(request.headers);
    }

    // Query Parameters
    if (options.includeQueryParams && request.queryParams?.length > 0) {
      doc += this.generateQueryParamsDocumentation(request.queryParams);
    }

    // Request Body
    if (options.includeBody && request.body && request.body.type !== 'none') {
      doc += this.generateBodyDocumentation(request);
    }

    // Example Request
    if (options.includeExamples) {
      doc += this.generateExampleRequest(request);
    }

    doc += `\n`;
    return doc;
  }

  /**
   * Generate authentication documentation
   */
  private generateAuthDocumentation(request: Request): string {
    let doc = `**Authentication:**\n\n`;

    switch (request.auth?.type) {
      case 'basic':
        doc += `- Type: Basic Auth\n`;
        if (request.auth.basic) {
          doc += `- Username: \`${request.auth.basic.username || 'username'}\`\n`;
          doc += `- Password: \`${request.auth.basic.password ? '••••••' : 'password'}\`\n`;
        }
        break;
      case 'bearer':
        doc += `- Type: Bearer Token\n`;
        if (request.auth.bearer) {
          doc += `- Token: \`${request.auth.bearer.token ? '••••••' : 'token'}\`\n`;
        }
        break;
      case 'apikey':
        doc += `- Type: API Key\n`;
        if (request.auth.apikey) {
          doc += `- Key: \`${request.auth.apikey.key || 'key'}\`\n`;
          doc += `- Value: \`${request.auth.apikey.value ? '••••••' : 'value'}\`\n`;
          doc += `- Location: \`${request.auth.apikey.addTo || 'header'}\`\n`;
        }
        break;
      case 'oauth2':
        doc += `- Type: OAuth 2.0\n`;
        break;
    }

    doc += `\n`;
    return doc;
  }

  /**
   * Generate headers documentation
   */
  private generateHeadersDocumentation(headers: Header[]): string {
    const enabledHeaders = headers.filter(h => h.enabled);
    if (enabledHeaders.length === 0) return '';

    let doc = `**Headers:**\n\n`;
    doc += `| Header | Value | Required |\n`;
    doc += `|--------|-------|----------|\n`;

    for (const header of enabledHeaders) {
      const value = header.value || '-';
      const required = header.enabled ? 'Yes' : 'No';
      doc += `| \`${header.key}\` | \`${value}\` | ${required} |\n`;
    }

    doc += `\n`;
    return doc;
  }

  /**
   * Generate query parameters documentation
   */
  private generateQueryParamsDocumentation(params: QueryParam[]): string {
    const enabledParams = params.filter(p => p.enabled);
    if (enabledParams.length === 0) return '';

    let doc = `**Query Parameters:**\n\n`;
    doc += `| Parameter | Value | Required |\n`;
    doc += `|-----------|-------|----------|\n`;

    for (const param of enabledParams) {
      const value = param.value || '-';
      const required = param.enabled ? 'Yes' : 'No';
      doc += `| \`${param.key}\` | \`${value}\` | ${required} |\n`;
    }

    doc += `\n`;
    return doc;
  }

  /**
   * Generate request body documentation
   */
  private generateBodyDocumentation(request: Request): string {
    if (!request.body || request.body.type === 'none') return '';

    let doc = `**Request Body:**\n\n`;

    switch (request.body.type) {
      case 'json':
        doc += `Type: \`application/json\`\n\n`;
        doc += '```json\n';
        doc += this.formatJSON(request.body.content);
        doc += '\n```\n\n';
        break;
      case 'xml':
        doc += `Type: \`application/xml\`\n\n`;
        doc += '```xml\n';
        doc += request.body.content;
        doc += '\n```\n\n';
        break;
      case 'raw':
        doc += `Type: \`text/plain\`\n\n`;
        doc += '```\n';
        doc += request.body.content;
        doc += '\n```\n\n';
        break;
      case 'form-data':
      case 'x-www-form-urlencoded':
        doc += `Type: \`application/x-www-form-urlencoded\`\n\n`;
        doc += '```\n';
        doc += request.body.content;
        doc += '\n```\n\n';
        break;
    }

    return doc;
  }

  /**
   * Generate example request
   */
  private generateExampleRequest(request: Request): string {
    let doc = `**Example Request:**\n\n`;

    // cURL example
    doc += '```bash\n';
    doc += this.generateCurlExample(request);
    doc += '\n```\n\n';

    // JavaScript example
    doc += '<details>\n';
    doc += '<summary>JavaScript Example</summary>\n\n';
    doc += '```javascript\n';
    doc += this.generateJavaScriptExample(request);
    doc += '\n```\n\n';
    doc += '</details>\n\n';

    // Python example
    doc += '<details>\n';
    doc += '<summary>Python Example</summary>\n\n';
    doc += '```python\n';
    doc += this.generatePythonExample(request);
    doc += '\n```\n\n';
    doc += '</details>\n\n';

    return doc;
  }

  /**
   * Generate cURL example
   */
  private generateCurlExample(request: Request): string {
    let curl = `curl -X ${request.method.toUpperCase()} "${request.url}"`;

    // Headers
    if (request.headers) {
      for (const header of request.headers.filter(h => h.enabled)) {
        curl += ` \\\n  -H "${header.key}: ${header.value}"`;
      }
    }

    // Auth
    if (request.auth) {
      if (request.auth.type === 'basic' && request.auth.basic) {
        curl += ` \\\n  -u "${request.auth.basic.username}:${request.auth.basic.password}"`;
      } else if (request.auth.type === 'bearer' && request.auth.bearer) {
        curl += ` \\\n  -H "Authorization: Bearer ${request.auth.bearer.token}"`;
      }
    }

    // Body
    if (request.body && request.body.type !== 'none') {
      const data = request.body.content.replace(/"/g, '\\"');
      curl += ` \\\n  -d "${data}"`;
    }

    return curl;
  }

  /**
   * Generate JavaScript example
   */
  private generateJavaScriptExample(request: Request): string {
    let js = `const response = await fetch('${request.url}', {\n`;
    js += `  method: '${request.method.toUpperCase()}',\n`;

    // Headers
    if (request.headers && request.headers.length > 0) {
      js += `  headers: {\n`;
      for (const header of request.headers.filter(h => h.enabled)) {
        js += `    '${header.key}': '${header.value}',\n`;
      }
      js += `  },\n`;
    }

    // Body
    if (request.body && request.body.type !== 'none') {
      js += `  body: ${request.body.type === 'json' ? 'JSON.stringify(' : ''}${request.body.content}${request.body.type === 'json' ? ')' : ''},\n`;
    }

    js += `});\n\n`;
    js += `const data = await response.json();\n`;
    js += `console.log(data);`;

    return js;
  }

  /**
   * Generate Python example
   */
  private generatePythonExample(request: Request): string {
    let py = `import requests\n\n`;

    // Headers
    if (request.headers && request.headers.length > 0) {
      py += `headers = {\n`;
      for (const header of request.headers.filter(h => h.enabled)) {
        py += `    '${header.key}': '${header.value}',\n`;
      }
      py += `}\n\n`;
    }

    // Body
    if (request.body && request.body.type === 'json') {
      py += `data = ${request.body.content}\n\n`;
    }

    // Request
    py += `response = requests.${request.method.toLowerCase()}(\n`;
    py += `    '${request.url}'`;
    if (request.headers && request.headers.length > 0) {
      py += `,\n    headers=headers`;
    }
    if (request.body && request.body.type === 'json') {
      py += `,\n    json=data`;
    }
    py += `\n)\n\n`;
    py += `print(response.json())`;

    return py;
  }

  /**
   * Get method badge
   */
  private getMethodBadge(method: string, format: string): string {
    const colors: Record<string, string> = {
      GET: '🟢',
      POST: '🔵',
      PUT: '🟡',
      PATCH: '🟠',
      DELETE: '🔴',
      HEAD: '⚪',
      OPTIONS: '⚫',
    };

    if (format === 'github' || format === 'gitlab') {
      return `![${method}](https://img.shields.io/badge/${method}-${this.getMethodColor(method)})`;
    }

    return `${colors[method] || '⚪'} **${method}**`;
  }

  /**
   * Get method color for badges
   */
  private getMethodColor(method: string): string {
    const colors: Record<string, string> = {
      GET: 'blue',
      POST: 'green',
      PUT: 'orange',
      PATCH: 'yellow',
      DELETE: 'red',
      HEAD: 'lightgrey',
      OPTIONS: 'grey',
    };
    return colors[method] || 'lightgrey';
  }

  /**
   * Create anchor link
   */
  private createAnchor(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-');
  }

  /**
   * Format JSON with proper indentation
   */
  private formatJSON(content: string): string {
    try {
      const obj = JSON.parse(content);
      return JSON.stringify(obj, null, 2);
    } catch {
      return content;
    }
  }

  /**
   * Save documentation to file
   */
  async saveToFile(
    markdown: string,
    filePath: string
  ): Promise<void> {
    try {
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(filePath, markdown, 'utf-8');
    } catch (error: any) {
      throw new Error(`Failed to save documentation: ${error.message}`);
    }
  }

  /**
   * Generate documentation for multiple collections
   */
  generateFromCollections(
    collections: Collection[],
    options: GeneratorOptions = {}
  ): string {
    let markdown = `# API Documentation\n\n`;
    markdown += `**Generated:** ${new Date().toISOString()}\n\n`;
    markdown += `**Total Collections:** ${collections.length}\n\n`;
    markdown += `---\n\n`;

    for (const collection of collections) {
      markdown += this.generateFromCollection(collection, {
        ...options,
        includeTableOfContents: false,
      });
      markdown += `\n---\n\n`;
    }

    return markdown;
  }
}

// Singleton instance
let markdownGeneratorInstance: MarkdownGenerator | null = null;

export function getMarkdownGenerator(): MarkdownGenerator {
  if (!markdownGeneratorInstance) {
    markdownGeneratorInstance = new MarkdownGenerator();
  }
  return markdownGeneratorInstance;
}
